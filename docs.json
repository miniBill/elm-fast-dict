[{"name":"FastDict","comment":" A dictionary mapping unique keys to values. The keys can be any comparable\ntype. This includes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or\nlists of comparable types.\n\nInsert, remove, and query operations all take _O(log n)_ time.\n\n\n# Dictionaries\n\n@docs Dict\n\n\n# Build\n\n@docs empty, singleton, insert, update, remove\n\n\n# Query\n\n@docs isEmpty, member, get, size, equals\n\n\n# Min / Max\n\n@docs getMinKey, getMin, getMaxKey, getMax\n\n@docs popMin, popMax\n\n\n# Lists\n\n@docs keys, values, toList, fromList\n\n\n# Transform\n\n@docs map, foldl, foldr, filter, partition\n\n\n# Combine\n\n@docs union, intersect, diff, merge\n\n\n# Interoperability\n\n@docs toCoreDict, fromCoreDict\n\n\n# Advanced functions\n\n@docs Step, stoppableFoldl, stoppableFoldr, restructure\n\n","unions":[{"name":"Step","comment":" A custom type used for stoppable folds.\n","args":["a"],"cases":[["Continue",["a"]],["Stop",["a"]]]}],"aliases":[{"name":"Dict","comment":" A dictionary of keys and values. So a `Dict String User` is a dictionary\nthat lets you look up a `String` (such as user names) and find the associated\n`User`.\n\n    import FastDict as Dict exposing (Dict)\n\n    users : Dict String User\n    users =\n        Dict.fromList\n            [ ( \"Alice\", User \"Alice\" 28 1.65 )\n            , ( \"Bob\", User \"Bob\" 19 1.82 )\n            , ( \"Chuck\", User \"Chuck\" 33 1.75 )\n            ]\n\n    type alias User =\n        { name : String\n        , age : Int\n        , height : Float\n        }\n\n","args":["k","v"],"type":"Internal.Dict k v"}],"values":[{"name":"diff","comment":" Keep a key-value pair when its key does not appear in the second dictionary.\n","type":"FastDict.Dict comparable a -> FastDict.Dict comparable b -> FastDict.Dict comparable a"},{"name":"empty","comment":" Create an empty dictionary.\n","type":"FastDict.Dict k v"},{"name":"equals","comment":" Determine if two dictionaries are equal. This is needed because the structure could be different depending on insertion order.\n","type":"FastDict.Dict comparable v -> FastDict.Dict comparable v -> Basics.Bool"},{"name":"filter","comment":" Keep only the key-value pairs that pass the given test.\n","type":"(comparable -> v -> Basics.Bool) -> FastDict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"foldl","comment":" Fold over the key-value pairs in a dictionary from lowest key to highest key.\n\n    getAges : Dict String Int -> List Int\n    getAges usersDict =\n        FastDict.foldl addAge [] usersDict\n\n    addAge : String -> Int -> List Int -> List Int\n    addAge _ age ages =\n        age :: ages\n\n    users : Dict String Int\n    users =\n        FastDict.fromList\n            [ ( \"Abe\", 28 )\n            , ( \"Beatrix\", 19 )\n            , ( \"Charlotte\", 33 )\n            ]\n\n    -- Note that the _fold_ is from lowest to highest,\n    -- but because we're adding items to the beginning of the list\n    -- the result will be from highest to lowest.\n\n    getAges users\n    --> [ 33, 19, 28 ]\n\n","type":"(k -> v -> b -> b) -> b -> FastDict.Dict k v -> b"},{"name":"foldr","comment":" Fold over the key-value pairs in a dictionary from highest key to lowest key.\n\n    getAges : Dict String Int -> List Int\n    getAges usersDict =\n        FastDict.foldr addAge [] usersDict\n\n    addAge : String -> Int -> List Int -> List Int\n    addAge _ age ages =\n        age :: ages\n\n    users : Dict String Int\n    users =\n        FastDict.fromList\n            [ ( \"Abe\", 28 )\n            , ( \"Beatrix\", 19 )\n            , ( \"Charlotte\", 33 )\n            ]\n\n    -- Note that the _fold_ is from highest to lowest,\n    -- but because we're adding items to the beginning of the list\n    -- the result will be from lowest to highest.\n\n    getAges users\n    --> [ 28, 19, 33 ]\n\n","type":"(k -> v -> b -> b) -> b -> FastDict.Dict k v -> b"},{"name":"fromCoreDict","comment":" Convert the dictionary from an equivalent one from elm/core.\n","type":"Dict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"fromList","comment":" Convert an association list into a dictionary.\n","type":"List.List ( comparable, v ) -> FastDict.Dict comparable v"},{"name":"get","comment":" Get the value associated with a key. If the key is not found, return\n`Nothing`. This is useful when you are not sure if a key will be in the\ndictionary.\n\n    animals : Dict String String\n    animals =\n        fromList [ (\"Tom\", \"Cat\"), (\"Jerry\", \"Mouse\") ]\n\n    get \"Tom\"   animals\n    --> Just \"Cat\"\n\n    get \"Jerry\" animals\n    --> Just \"Mouse\"\n\n    get \"Spike\" animals\n    --> Nothing\n\n","type":"comparable -> FastDict.Dict comparable v -> Maybe.Maybe v"},{"name":"getMax","comment":" Gets the key-value pair with the biggest key.\n\n    [ ( 1, 'z' ), ( 2, 'a' ) ]\n        |> fromList\n        |> getMax\n    --> Just ( 2, 'a' )\n\n\n    empty\n        |> getMax\n    --> Nothing\n\n","type":"FastDict.Dict k v -> Maybe.Maybe ( k, v )"},{"name":"getMaxKey","comment":" Gets the biggest key in the dictionary.\n\n    [ ( 1, 'z' ), ( 2, 'a' ) ]\n        |> fromList\n        |> getMaxKey\n    --> Just 2\n\n\n    empty\n        |> getMaxKey\n    --> Nothing\n\n","type":"FastDict.Dict k v -> Maybe.Maybe k"},{"name":"getMin","comment":" Gets the key-value pair with the smallest key.\n\n    [ ( 1, 'z' ), ( 2, 'a' ) ]\n        |> fromList\n        |> getMin\n    --> Just ( 1, 'z' )\n\n\n    empty\n        |> getMin\n    --> Nothing\n\n","type":"FastDict.Dict k v -> Maybe.Maybe ( k, v )"},{"name":"getMinKey","comment":" Gets the smallest key in the dictionary.\n\n    [ ( 1, 'z' ), ( 2, 'a' ) ]\n        |> fromList\n        |> getMinKey\n    --> Just 1\n\n\n    empty\n        |> getMinKey\n    --> Nothing\n\n","type":"FastDict.Dict k v -> Maybe.Maybe k"},{"name":"insert","comment":" Insert a key-value pair into a dictionary. Replaces value when there is\na collision.\n","type":"comparable -> v -> FastDict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"intersect","comment":" Keep a key-value pair when its key appears in the second dictionary.\nPreference is given to values in the first dictionary.\n","type":"FastDict.Dict comparable v -> FastDict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"isEmpty","comment":" Determine if a dictionary is empty.\n\n    isEmpty empty\n    --> True\n\n","type":"FastDict.Dict k v -> Basics.Bool"},{"name":"keys","comment":" Get all of the keys in a dictionary, sorted from lowest to highest.\n\n    keys (fromList [ ( 0, \"Alice\" ), ( 1, \"Bob\" ) ])\n    --> [ 0, 1 ]\n\n","type":"FastDict.Dict k v -> List.List k"},{"name":"map","comment":" Apply a function to all values in a dictionary.\n","type":"(k -> a -> b) -> FastDict.Dict k a -> FastDict.Dict k b"},{"name":"member","comment":" Determine if a key is in a dictionary.\n","type":"comparable -> FastDict.Dict comparable v -> Basics.Bool"},{"name":"merge","comment":" The most general way of combining two dictionaries. You provide three\naccumulators for when a given key appears:\n\n1.  Only in the left dictionary.\n2.  In both dictionaries.\n3.  Only in the right dictionary.\n\nYou then traverse all the keys from lowest to highest, building up whatever\nyou want.\n\n","type":"(comparable -> a -> result -> result) -> (comparable -> a -> b -> result -> result) -> (comparable -> b -> result -> result) -> FastDict.Dict comparable a -> FastDict.Dict comparable b -> result -> result"},{"name":"partition","comment":" Partition a dictionary according to some test. The first dictionary\ncontains all key-value pairs which passed the test, and the second contains\nthe pairs that did not.\n","type":"(comparable -> v -> Basics.Bool) -> FastDict.Dict comparable v -> ( FastDict.Dict comparable v, FastDict.Dict comparable v )"},{"name":"popMax","comment":" Removes the key-value pair with the biggest key from the dictionary, and returns it.\n\n    [ ( 1, 'z' ), ( 2, 'a' ) ]\n        |> fromList\n        |> popMax\n    --> Just ( ( 2, 'a' ), fromList [ ( 1, 'z' ) ] )\n\n\n    empty\n        |> popMax\n    --> Nothing\n\n","type":"FastDict.Dict comparable v -> Maybe.Maybe ( ( comparable, v ), FastDict.Dict comparable v )"},{"name":"popMin","comment":" Removes the key-value pair with the smallest key from the dictionary, and returns it.\n\n    [ ( 1, 'z' ), ( 2, 'a' ) ]\n        |> fromList\n        |> popMin\n    --> Just ( ( 1, 'z' ), fromList [ ( 2, 'a' ) ] )\n\n\n    empty\n        |> popMin\n    --> Nothing\n\n","type":"FastDict.Dict comparable v -> Maybe.Maybe ( ( comparable, v ), FastDict.Dict comparable v )"},{"name":"remove","comment":" Remove a key-value pair from a dictionary. If the key is not found,\nno changes are made.\n","type":"comparable -> FastDict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"restructure","comment":" This allows you to take advantage of the tree structure of the dictionary to do some operations more efficiently.\n\nCalling `left` will give the result of calling `restructure` on the left subtree (lower keys), `right` on the right one (higher keys).\n\nIf this is confusing you probably don't need this function!\n\n    any dict =\n        -- Notice how if `value` is `True` we don't call `left` nor `right`,\n        -- and if `value` is `False` but `left ()` is `True` we don't call right.\n        restructure False (\\{ value, left, right } -> value || left () || right ())\n\n","type":"acc -> ({ key : key, value : value, left : () -> acc, right : () -> acc } -> acc) -> FastDict.Dict key value -> acc"},{"name":"singleton","comment":" Create a dictionary with one key-value pair.\n","type":"comparable -> v -> FastDict.Dict comparable v"},{"name":"size","comment":" Determine the number of key-value pairs in the dictionary.\n","type":"FastDict.Dict k v -> Basics.Int"},{"name":"stoppableFoldl","comment":" A foldl that can stop early instead of traversing the whole dictionary.\n\n    stoppableFoldl\n        (\\k v acc ->\n            if k >= 10 then\n                Stop acc\n            else\n                Continue (v + acc)\n        )\n        0\n        (fromList <| List.indexedMap Tuple.pair <| List.range 1 10000)\n    --> 55\n\n","type":"(k -> v -> acc -> FastDict.Step acc) -> acc -> FastDict.Dict k v -> acc"},{"name":"stoppableFoldr","comment":" A foldr that can stop early instead of traversing the whole dictionary.\n\n    stoppableFoldr\n        (\\k v acc ->\n            if k <= 9990 then\n                Stop acc\n            else\n                Continue (v + acc)\n        )\n        0\n        (fromList <| List.indexedMap Tuple.pair <| List.range 1 10000)\n    --> 89964\n\n","type":"(k -> v -> acc -> FastDict.Step acc) -> acc -> FastDict.Dict k v -> acc"},{"name":"toCoreDict","comment":" Convert the dictionary into an equivalent one from elm/core.\n","type":"FastDict.Dict comparable v -> Dict.Dict comparable v"},{"name":"toList","comment":" Convert a dictionary into an association list of key-value pairs, sorted by keys.\n","type":"FastDict.Dict k v -> List.List ( k, v )"},{"name":"union","comment":" Combine two dictionaries. If there is a collision, preference is given\nto the first dictionary.\n","type":"FastDict.Dict comparable v -> FastDict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"update","comment":" Update the value of a dictionary for a specific key with a given function.\n","type":"comparable -> (Maybe.Maybe v -> Maybe.Maybe v) -> FastDict.Dict comparable v -> FastDict.Dict comparable v"},{"name":"values","comment":" Get all of the values in a dictionary, in the order of their keys.\n\n    values (fromList [ ( 0, \"Alice\" ), ( 1, \"Bob\" ) ])\n    --> [ \"Alice\", \"Bob\" ]\n\n","type":"FastDict.Dict k v -> List.List v"}],"binops":[]},{"name":"FastSet","comment":" A set of unique values. The values can be any comparable type.\nThis includes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or lists of comparable types.\n\nInsert, remove, and query operations all take _O(log n)_ time.\n\n\n# Sets\n\n@docs Set\n\n\n# Build\n\n@docs empty, singleton, insert, remove\n\n\n# Query\n\n@docs isEmpty, member, size, equals\n\n\n# Combine\n\n@docs union, intersect, diff\n\n\n# Lists\n\n@docs toList, fromList\n\n\n# Min / Max\n\n@docs getMin, getMax\n\n@docs popMin, popMax\n\n\n# Transform\n\n@docs map, foldl, foldr, filter, partition\n\n\n# Interoperability\n\n@docs toCoreSet, fromCoreSet\n\n\n# Advanced functions\n\n@docs stoppableFoldl, stoppableFoldr\n\n","unions":[{"name":"Set","comment":" Represents a set of unique values. So `(Set Int)` is a set of integers and `(Set String)` is a set of strings.\n","args":["t"],"cases":[]}],"aliases":[],"values":[{"name":"diff","comment":" Get the difference between the first set and the second. Keeps values that do not appear in the second set.\n","type":"FastSet.Set comparable -> FastSet.Set comparable -> FastSet.Set comparable"},{"name":"empty","comment":" Create an empty set.\n","type":"FastSet.Set t"},{"name":"equals","comment":" Determine if two sets are equal. This is needed because the structure could be different depending on insertion order.\n","type":"FastSet.Set comparable -> FastSet.Set comparable -> Basics.Bool"},{"name":"filter","comment":" Keep only the values that pass the given test.\n","type":"(comparable -> Basics.Bool) -> FastSet.Set comparable -> FastSet.Set comparable"},{"name":"foldl","comment":" Fold over the values in a set from lowest to highest.\n","type":"(v -> b -> b) -> b -> FastSet.Set v -> b"},{"name":"foldr","comment":" Fold over the values in a set from highest to lowest.\n","type":"(v -> b -> b) -> b -> FastSet.Set v -> b"},{"name":"fromCoreSet","comment":" Convert the set from an equivalent one from elm/core.\n","type":"Set.Set comparable -> FastSet.Set comparable"},{"name":"fromList","comment":" Convert an association list into a set.\n","type":"List.List comparable -> FastSet.Set comparable"},{"name":"getMax","comment":" Gets the biggest value.\n\n    [ 1, 2 ]\n        |> fromList\n        |> getMax\n    --> Just 2\n\n\n    empty\n        |> getMax\n    --> Nothing\n\n","type":"FastSet.Set v -> Maybe.Maybe v"},{"name":"getMin","comment":" Gets the smallest value.\n\n    [ 1, 2 ]\n        |> fromList\n        |> getMin\n    --> Just 1\n\n\n    empty\n        |> getMin\n    --> Nothing\n\n","type":"FastSet.Set v -> Maybe.Maybe v"},{"name":"insert","comment":" Insert a value into a set.\n","type":"comparable -> FastSet.Set comparable -> FastSet.Set comparable"},{"name":"intersect","comment":" Get the intersection of two sets. Keeps values that appear in both sets.\n","type":"FastSet.Set comparable -> FastSet.Set comparable -> FastSet.Set comparable"},{"name":"isEmpty","comment":" Determine if a set is empty.\n\n    isEmpty empty\n    --> True\n\n","type":"FastSet.Set k -> Basics.Bool"},{"name":"map","comment":" Apply a function to all values in a set.\n","type":"(comparable -> comparable2) -> FastSet.Set comparable -> FastSet.Set comparable2"},{"name":"member","comment":" Determine if a value is in a set.\n","type":"comparable -> FastSet.Set comparable -> Basics.Bool"},{"name":"partition","comment":" Partition a set according to some test. The first set\ncontains all values which passed the test, and the second contains\nthe pairs that did not.\n","type":"(comparable -> Basics.Bool) -> FastSet.Set comparable -> ( FastSet.Set comparable, FastSet.Set comparable )"},{"name":"popMax","comment":" Removes the biggest value from the set, and returns it.\n\n    [ 1, 2 ]\n        |> fromList\n        |> popMax\n    --> Just ( 2, fromList [ 1 ] )\n\n\n    empty\n        |> popMax\n    --> Nothing\n\n","type":"FastSet.Set comparable -> Maybe.Maybe ( comparable, FastSet.Set comparable )"},{"name":"popMin","comment":" Removes the smallest value from the set, and returns it.\n\n    [ 1, 2 ]\n        |> fromList\n        |> popMin\n    --> Just ( 1, fromList [ 2 ] )\n\n\n    empty\n        |> popMin\n    --> Nothing\n\n","type":"FastSet.Set comparable -> Maybe.Maybe ( comparable, FastSet.Set comparable )"},{"name":"remove","comment":" Remove a value from a set. If the value is not found,\nno changes are made.\n","type":"comparable -> FastSet.Set comparable -> FastSet.Set comparable"},{"name":"singleton","comment":" Create a set with one value.\n","type":"comparable -> FastSet.Set comparable"},{"name":"size","comment":" Determine the number of elements in a set.\n","type":"FastSet.Set t -> Basics.Int"},{"name":"stoppableFoldl","comment":" A foldl that can stop early instead of traversing the whole set.\n\n    stoppableFoldl\n        (\\v acc ->\n            if v >= 10 then\n                Stop acc\n            else\n                Continue (v + acc)\n        )\n        0\n        (fromList <| List.range 1 10000)\n    --> 55\n\n","type":"(v -> acc -> FastDict.Step acc) -> acc -> FastSet.Set v -> acc"},{"name":"stoppableFoldr","comment":" A foldr that can stop early instead of traversing the whole set.\n\n    stoppableFoldr\n        (\\v acc ->\n            if v <= 9990 then\n                Stop acc\n            else\n                Continue (v + acc)\n        )\n        0\n        (fromList <| List.range 1 10000)\n    --> 89964\n\n","type":"(v -> acc -> FastDict.Step acc) -> acc -> FastSet.Set v -> acc"},{"name":"toCoreSet","comment":" Convert the set into an equivalent one from elm/core.\n","type":"FastSet.Set comparable -> Set.Set comparable"},{"name":"toList","comment":" Convert a set into a list, sorted from lowest to highest.\n","type":"FastSet.Set k -> List.List k"},{"name":"union","comment":" Get the union of two sets. Keep all values.\n","type":"FastSet.Set comparable -> FastSet.Set comparable -> FastSet.Set comparable"}],"binops":[]}]